  globals .f .t .cond .quote .error .write-char .peek-char .read-char .set-car! .cdr .car .cons .char? .pair? .null? .eq? .eof-object .define .abort false symbols definitions global-vars global-vals
  char 'f'
  nil
  prim 2 cons
  checkdef .f
  char 't'
  nil
  prim 2 cons
  checkdef .t
  char 'c'
  char 'o'
  char 'n'
  char 'd'
  nil
  prim 2 cons
  prim 2 cons
  prim 2 cons
  prim 2 cons
  checkdef .cond
  char 'q'
  char 'u'
  char 'o'
  char 't'
  char 'e'
  nil
  prim 2 cons
  prim 2 cons
  prim 2 cons
  prim 2 cons
  prim 2 cons
  checkdef .quote
  char 'e'
  char 'r'
  char 'r'
  char 'o'
  char 'r'
  nil
  prim 2 cons
  prim 2 cons
  prim 2 cons
  prim 2 cons
  prim 2 cons
  checkdef .error
  char 'w'
  char 'r'
  char 'i'
  char 't'
  char 'e'
  char '-'
  char 'c'
  char 'h'
  char 'a'
  char 'r'
  nil
  prim 2 cons
  prim 2 cons
  prim 2 cons
  prim 2 cons
  prim 2 cons
  prim 2 cons
  prim 2 cons
  prim 2 cons
  prim 2 cons
  prim 2 cons
  checkdef .write-char
  char 'p'
  char 'e'
  char 'e'
  char 'k'
  char '-'
  char 'c'
  char 'h'
  char 'a'
  char 'r'
  nil
  prim 2 cons
  prim 2 cons
  prim 2 cons
  prim 2 cons
  prim 2 cons
  prim 2 cons
  prim 2 cons
  prim 2 cons
  prim 2 cons
  checkdef .peek-char
  char 'r'
  char 'e'
  char 'a'
  char 'd'
  char '-'
  char 'c'
  char 'h'
  char 'a'
  char 'r'
  nil
  prim 2 cons
  prim 2 cons
  prim 2 cons
  prim 2 cons
  prim 2 cons
  prim 2 cons
  prim 2 cons
  prim 2 cons
  prim 2 cons
  checkdef .read-char
  char 's'
  char 'e'
  char 't'
  char '-'
  char 'c'
  char 'a'
  char 'r'
  char '!'
  nil
  prim 2 cons
  prim 2 cons
  prim 2 cons
  prim 2 cons
  prim 2 cons
  prim 2 cons
  prim 2 cons
  prim 2 cons
  checkdef .set-car!
  char 'c'
  char 'd'
  char 'r'
  nil
  prim 2 cons
  prim 2 cons
  prim 2 cons
  checkdef .cdr
  char 'c'
  char 'a'
  char 'r'
  nil
  prim 2 cons
  prim 2 cons
  prim 2 cons
  checkdef .car
  char 'c'
  char 'o'
  char 'n'
  char 's'
  nil
  prim 2 cons
  prim 2 cons
  prim 2 cons
  prim 2 cons
  checkdef .cons
  char 'c'
  char 'h'
  char 'a'
  char 'r'
  char '?'
  nil
  prim 2 cons
  prim 2 cons
  prim 2 cons
  prim 2 cons
  prim 2 cons
  checkdef .char?
  char 'p'
  char 'a'
  char 'i'
  char 'r'
  char '?'
  nil
  prim 2 cons
  prim 2 cons
  prim 2 cons
  prim 2 cons
  prim 2 cons
  checkdef .pair?
  char 'n'
  char 'u'
  char 'l'
  char 'l'
  char '?'
  nil
  prim 2 cons
  prim 2 cons
  prim 2 cons
  prim 2 cons
  prim 2 cons
  checkdef .null?
  char 'e'
  char 'q'
  char '?'
  nil
  prim 2 cons
  prim 2 cons
  prim 2 cons
  checkdef .eq?
  char 'e'
  char 'o'
  char 'f'
  char '-'
  char 'o'
  char 'b'
  char 'j'
  char 'e'
  char 'c'
  char 't'
  nil
  prim 2 cons
  prim 2 cons
  prim 2 cons
  prim 2 cons
  prim 2 cons
  prim 2 cons
  prim 2 cons
  prim 2 cons
  prim 2 cons
  prim 2 cons
  checkdef .eof-object
  char 'd'
  char 'e'
  char 'f'
  char 'i'
  char 'n'
  char 'e'
  nil
  prim 2 cons
  prim 2 cons
  prim 2 cons
  prim 2 cons
  prim 2 cons
  prim 2 cons
  checkdef .define
  char 'a'
  char 'b'
  char 'o'
  char 'r'
  char 't'
  nil
  prim 2 cons
  prim 2 cons
  prim 2 cons
  prim 2 cons
  prim 2 cons
  checkdef .abort
  false
  checkdef false
  global .t
  global .f
  global .eof-object
  global .define
  global .quote
  global .cond
  global .eq?
  global .null?
  global .pair?
  global .char?
  global .cons
  global .car
  global .cdr
  global .set-car!
  global .read-char
  global .peek-char
  global .write-char
  global .abort
  nil
  prim 2 cons
  prim 2 cons
  prim 2 cons
  prim 2 cons
  prim 2 cons
  prim 2 cons
  prim 2 cons
  prim 2 cons
  prim 2 cons
  prim 2 cons
  prim 2 cons
  prim 2 cons
  prim 2 cons
  prim 2 cons
  prim 2 cons
  prim 2 cons
  prim 2 cons
  prim 2 cons
  nil
  prim 2 cons
  checkdef symbols
  nil
  nil
  prim 2 cons
  checkdef definitions
  nil
  nil
  prim 2 cons
  checkdef global-vars
  nil
  nil
  prim 2 cons
  checkdef global-vals
  call 0 __main
  halt

proc __main
  locals
  global .write-char
  char 'a'
  nil
  prim 2 cons
  prim 2 cons
  tailcall 1 eval-form

proc call
  locals rator args defs
  local defs
  prim 1 null?
  if
  char 'U'
  char 'n'
  char 'k'
  char 'n'
  char 'o'
  char 'w'
  char 'n'
  char ' '
  char 'r'
  char 'a'
  char 't'
  char 'o'
  char 'r'
  nil
  prim 2 cons
  prim 2 cons
  prim 2 cons
  prim 2 cons
  prim 2 cons
  prim 2 cons
  prim 2 cons
  prim 2 cons
  prim 2 cons
  prim 2 cons
  prim 2 cons
  prim 2 cons
  prim 2 cons
  tailcall 1 error
  else
  local rator
  local defs
  prim 1 car
  prim 1 car
  prim 1 car
  prim 2 eq?
  if
  local defs
  prim 1 car
  prim 1 cdr
  local defs
  prim 1 car
  prim 1 car
  prim 1 cdr
  local args
  tailcall 3 evseq
  else
  global .t
  if
  local rator
  local args
  local defs
  prim 1 cdr
  tailcall 3 call
  else
  false
  return
  then
  then
  then

proc apply
  locals rator args
  local rator
  global .eq?
  prim 2 eq?
  if
  local args
  prim 1 car
  local args
  prim 1 cdr
  prim 1 car
  prim 2 eq?
  return
  else
  local rator
  global .null?
  prim 2 eq?
  if
  local args
  prim 1 car
  prim 1 null?
  return
  else
  local rator
  global .pair?
  prim 2 eq?
  if
  local args
  prim 1 car
  prim 1 pair?
  return
  else
  local rator
  global .char?
  prim 2 eq?
  if
  local args
  prim 1 car
  prim 1 char?
  return
  else
  local rator
  global .cons
  prim 2 eq?
  if
  local args
  prim 1 car
  local args
  prim 1 cdr
  prim 1 car
  prim 2 cons
  return
  else
  local rator
  global .car
  prim 2 eq?
  if
  local args
  prim 1 car
  prim 1 car
  return
  else
  local rator
  global .cdr
  prim 2 eq?
  if
  local args
  prim 1 car
  prim 1 cdr
  return
  else
  local rator
  global .set-car!
  prim 2 eq?
  if
  local args
  prim 1 car
  local args
  prim 1 cdr
  prim 1 car
  prim 2 set-car!
  return
  else
  local rator
  global .read-char
  prim 2 eq?
  if
  prim 0 read-char
  return
  else
  local rator
  global .peek-char
  prim 2 eq?
  if
  prim 0 peek-char
  return
  else
  local rator
  global .write-char
  prim 2 eq?
  if
  local args
  prim 1 car
  prim 1 write-char
  return
  else
  local rator
  global .error
  prim 2 eq?
  if
  local args
  prim 1 car
  tailcall 1 error
  else
  global .t
  if
  local rator
  local args
  global definitions
  prim 1 car
  tailcall 3 call
  else
  false
  return
  then
  then
  then
  then
  then
  then
  then
  then
  then
  then
  then
  then
  then

proc lookup1
  locals var vars vals
  local vars
  prim 1 null?
  if
  char 'U'
  char 'n'
  char 'b'
  char 'o'
  char 'u'
  char 'n'
  char 'd'
  char ' '
  char 'v'
  char 'a'
  char 'r'
  char 'i'
  char 'a'
  char 'b'
  char 'l'
  char 'e'
  char ' '
  char 'y'
  char 'o'
  nil
  prim 2 cons
  prim 2 cons
  prim 2 cons
  prim 2 cons
  prim 2 cons
  prim 2 cons
  prim 2 cons
  prim 2 cons
  prim 2 cons
  prim 2 cons
  prim 2 cons
  prim 2 cons
  prim 2 cons
  prim 2 cons
  prim 2 cons
  prim 2 cons
  prim 2 cons
  prim 2 cons
  prim 2 cons
  tailcall 1 error
  else
  local var
  local vars
  prim 1 car
  prim 2 eq?
  if
  local vals
  prim 1 car
  return
  else
  global .t
  if
  local var
  local vars
  prim 1 cdr
  local vals
  prim 1 cdr
  tailcall 3 lookup1
  else
  false
  return
  then
  then
  then

proc lookup
  locals var vars vals
  local vars
  prim 1 null?
  if
  local var
  global global-vars
  prim 1 car
  global global-vals
  prim 1 car
  tailcall 3 lookup1
  else
  local var
  local vars
  prim 1 car
  prim 2 eq?
  if
  local vals
  prim 1 car
  return
  else
  global .t
  if
  local var
  local vars
  prim 1 cdr
  local vals
  prim 1 cdr
  tailcall 3 lookup
  else
  false
  return
  then
  then
  then

proc evseq
  locals es vars vals
  local es
  prim 1 cdr
  prim 1 null?
  if
  local es
  prim 1 car
  local vars
  local vals
  tailcall 3 eval
  else
  global .t
  if
  local es
  prim 1 car
  local vars
  local vals
  call 3 eval
  pop
  local es
  prim 1 cdr
  local vars
  local vals
  tailcall 3 evseq
  else
  false
  return
  then
  then

proc evcond
  locals clauses vars vals
  local clauses
  prim 1 null?
  if
  char 'N'
  char 'o'
  char ' '
  char 'm'
  char 'a'
  char 't'
  char 'c'
  char 'h'
  char 'i'
  char 'n'
  char 'g'
  char ' '
  char 'c'
  char 'o'
  char 'n'
  char 'd'
  char ' '
  char 'c'
  char 'l'
  char 'a'
  char 'u'
  char 's'
  char 'e'
  char ' '
  char 'y'
  char 'o'
  nil
  prim 2 cons
  prim 2 cons
  prim 2 cons
  prim 2 cons
  prim 2 cons
  prim 2 cons
  prim 2 cons
  prim 2 cons
  prim 2 cons
  prim 2 cons
  prim 2 cons
  prim 2 cons
  prim 2 cons
  prim 2 cons
  prim 2 cons
  prim 2 cons
  prim 2 cons
  prim 2 cons
  prim 2 cons
  prim 2 cons
  prim 2 cons
  prim 2 cons
  prim 2 cons
  prim 2 cons
  prim 2 cons
  prim 2 cons
  return
  else
  local clauses
  prim 1 car
  prim 1 car
  local vars
  local vals
  call 3 eval
  if
  local clauses
  prim 1 car
  prim 1 cdr
  local vars
  local vals
  tailcall 3 evseq
  else
  global .t
  if
  local clauses
  prim 1 cdr
  local vars
  local vals
  tailcall 3 evcond
  else
  false
  return
  then
  then
  then

proc evlis
  locals es vars vals
  local es
  prim 1 null?
  if
  nil
  return
  else
  global .t
  if
  local es
  prim 1 car
  local vars
  local vals
  call 3 eval
  local es
  prim 1 cdr
  local vars
  local vals
  call 3 evlis
  prim 2 cons
  return
  else
  false
  return
  then
  then

proc eval-pair
  locals rator rands vars vals
  local rator
  global .quote
  prim 2 eq?
  if
  local rands
  prim 1 car
  return
  else
  local rator
  global .cond
  prim 2 eq?
  if
  local rands
  local vars
  local vals
  tailcall 3 evcond
  else
  global .t
  if
  local rator
  local rands
  local vars
  local vals
  call 3 evlis
  tailcall 2 apply
  else
  false
  return
  then
  then
  then

proc eval
  locals e vars vals
  local e
  prim 1 pair?
  if
  local e
  call 1 symbol?
  if
  local e
  local vars
  local vals
  tailcall 3 lookup
  else
  global .t
  if
  local e
  prim 1 car
  local e
  prim 1 cdr
  local vars
  local vals
  tailcall 4 eval-pair
  else
  false
  return
  then
  then
  else
  global .t
  if
  local e
  return
  else
  false
  return
  then
  then

proc eval-form
  locals form
  local form
  nil
  nil
  tailcall 3 eval

proc error
  locals plaint
  local plaint
  call 1 write-string
  pop
  call 0 newline
  pop
  prim 0 abort
  return

proc write-string
  locals chars
  local chars
  prim 1 null?
  if
  global false
  return
  else
  global .t
  if
  local chars
  prim 1 car
  prim 1 write-char
  pop
  local chars
  prim 1 cdr
  tailcall 1 write-string
  else
  false
  return
  then
  then

proc newline
  locals
  char '\n'
  prim 1 write-char
  return

proc symbol?
  locals x
  local x
  global symbols
  prim 1 car
  tailcall 2 memq?

proc memq?
  locals x xs
  local xs
  prim 1 null?
  if
  global false
  return
  else
  local x
  local xs
  prim 1 car
  prim 2 eq?
  if
  global .t
  return
  else
  global .t
  if
  local x
  local xs
  prim 1 cdr
  tailcall 2 memq?
  else
  false
  return
  then
  then
  then

proc string?
  locals x
  local x
  prim 1 null?
  if
  global .t
  return
  else
  local x
  prim 1 char?
  if
  global false
  return
  else
  local x
  prim 1 car
  prim 1 char?
  if
  local x
  prim 1 cdr
  tailcall 1 string?
  else
  global .t
  if
  global false
  return
  else
  false
  return
  then
  then
  then
  then
